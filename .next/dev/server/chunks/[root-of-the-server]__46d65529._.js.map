{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/lib/validation/auth.ts"],"sourcesContent":["import { z } from 'zod'\r\n\r\n/**\r\n * Sign-in schema with email and password validation.\r\n * Used for login forms.\r\n */\r\nexport const signInSchema = z.object({\r\n  email: z\r\n    .string()\r\n    .min(1, { message: 'E-posta adresi gereklidir' })\r\n    .email({ message: 'Geçerli bir e-posta adresi giriniz' }),\r\n  password: z\r\n    .string()\r\n    .min(1, { message: 'Şifre gereklidir' })\r\n    .min(6, { message: 'Şifre en az 6 karakter olmalıdır' }),\r\n})\r\n\r\nexport type SignInInput = z.infer<typeof signInSchema>\r\n\r\n/**\r\n * Sign-up schema with name, email, phone, and password validation.\r\n * Used for customer self-registration.\r\n */\r\nexport const signUpSchema = z.object({\r\n  name: z\r\n    .string()\r\n    .min(1, { message: 'Ad soyad gereklidir' })\r\n    .min(2, { message: 'Ad soyad en az 2 karakter olmalıdır' }),\r\n  email: z\r\n    .string()\r\n    .min(1, { message: 'E-posta adresi gereklidir' })\r\n    .email({ message: 'Geçerli bir e-posta adresi giriniz' }),\r\n  phone: z\r\n    .string()\r\n    .optional()\r\n    .refine(\r\n      (val) => !val || /^(\\+90|0)?5\\d{9}$/.test(val.replace(/\\s/g, '')),\r\n      { message: 'Geçerli bir telefon numarası giriniz (örn: 5551234567)' }\r\n    ),\r\n  password: z\r\n    .string()\r\n    .min(1, { message: 'Şifre gereklidir' })\r\n    .min(6, { message: 'Şifre en az 6 karakter olmalıdır' }),\r\n  confirmPassword: z.string().min(1, { message: 'Şifre tekrarı gereklidir' }),\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n  message: 'Şifreler eşleşmiyor',\r\n  path: ['confirmPassword'],\r\n})\r\n\r\nexport type SignUpInput = z.infer<typeof signUpSchema>\r\n\r\n/**\r\n * Password reset request schema.\r\n * Used for initiating password reset flow.\r\n */\r\nexport const passwordResetRequestSchema = z.object({\r\n  email: z\r\n    .string()\r\n    .min(1, { message: 'E-posta adresi gereklidir' })\r\n    .email({ message: 'Geçerli bir e-posta adresi giriniz' }),\r\n})\r\n\r\nexport type PasswordResetRequestInput = z.infer<typeof passwordResetRequestSchema>\r\n\r\n/**\r\n * Password reset confirmation schema.\r\n * Used for completing password reset with token.\r\n */\r\nexport const passwordResetConfirmSchema = z.object({\r\n  token: z.string().min(1, { message: 'Token gereklidir' }),\r\n  password: z\r\n    .string()\r\n    .min(1, { message: 'Şifre gereklidir' })\r\n    .min(6, { message: 'Şifre en az 6 karakter olmalıdır' }),\r\n  confirmPassword: z.string().min(1, { message: 'Şifre tekrarı gereklidir' }),\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n  message: 'Şifreler eşleşmiyor',\r\n  path: ['confirmPassword'],\r\n})\r\n\r\nexport type PasswordResetConfirmInput = z.infer<typeof passwordResetConfirmSchema>\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAMO,MAAM,eAAe,qOAAC,CAAC,MAAM,CAAC;IACnC,OAAO,qOAAC,CACL,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAA4B,GAC9C,KAAK,CAAC;QAAE,SAAS;IAAqC;IACzD,UAAU,qOAAC,CACR,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmB,GACrC,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmC;AAC1D;AAQO,MAAM,eAAe,qOAAC,CAAC,MAAM,CAAC;IACnC,MAAM,qOAAC,CACJ,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAAsB,GACxC,GAAG,CAAC,GAAG;QAAE,SAAS;IAAsC;IAC3D,OAAO,qOAAC,CACL,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAA4B,GAC9C,KAAK,CAAC;QAAE,SAAS;IAAqC;IACzD,OAAO,qOAAC,CACL,MAAM,GACN,QAAQ,GACR,MAAM,CACL,CAAC,MAAQ,CAAC,OAAO,oBAAoB,IAAI,CAAC,IAAI,OAAO,CAAC,OAAO,MAC7D;QAAE,SAAS;IAAyD;IAExE,UAAU,qOAAC,CACR,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmB,GACrC,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmC;IACxD,iBAAiB,qOAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAA2B;AAC3E,GAAG,MAAM,CAAC,CAAC,OAAS,KAAK,QAAQ,KAAK,KAAK,eAAe,EAAE;IAC1D,SAAS;IACT,MAAM;QAAC;KAAkB;AAC3B;AAQO,MAAM,6BAA6B,qOAAC,CAAC,MAAM,CAAC;IACjD,OAAO,qOAAC,CACL,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAA4B,GAC9C,KAAK,CAAC;QAAE,SAAS;IAAqC;AAC3D;AAQO,MAAM,6BAA6B,qOAAC,CAAC,MAAM,CAAC;IACjD,OAAO,qOAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmB;IACvD,UAAU,qOAAC,CACR,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmB,GACrC,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmC;IACxD,iBAAiB,qOAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAA2B;AAC3E,GAAG,MAAM,CAAC,CAAC,OAAS,KAAK,QAAQ,KAAK,KAAK,eAAe,EAAE;IAC1D,SAAS;IACT,MAAM;QAAC;KAAkB;AAC3B","debugId":null}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/lib/utils/password.ts"],"sourcesContent":["import { hash, compare } from \"bcryptjs\";\r\n\r\nconst SALT_ROUNDS = 10;\r\n\r\n/**\r\n * Hash a plain-text password using bcryptjs.\r\n * @param password - Plain-text password\r\n * @returns Hashed password string\r\n */\r\nexport async function hashPassword(password: string): Promise<string> {\r\n  return hash(password, SALT_ROUNDS);\r\n}\r\n\r\n/**\r\n * Verify a plain-text password against a hashed password.\r\n * @param password - Plain-text password\r\n * @param hashedPassword - Hashed password from database\r\n * @returns True if passwords match, false otherwise\r\n */\r\nexport async function verifyPassword(\r\n  password: string,\r\n  hashedPassword: string\r\n): Promise<boolean> {\r\n  return compare(password, hashedPassword);\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,MAAM,cAAc;AAOb,eAAe,aAAa,QAAgB;IACjD,OAAO,IAAA,gMAAI,EAAC,UAAU;AACxB;AAQO,eAAe,eACpB,QAAgB,EAChB,cAAsB;IAEtB,OAAO,IAAA,mMAAO,EAAC,UAAU;AAC3B","debugId":null}},
    {"offset": {"line": 212, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/lib/auth.ts"],"sourcesContent":["import NextAuth, { NextAuthOptions } from \"next-auth\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\nimport CredentialsProvider from \"next-auth/providers/credentials\";\r\nimport { signInSchema } from \"@/lib/validation/auth\";\r\nimport { verifyPassword } from \"@/lib/utils/password\";\r\nimport { ZodError } from \"zod\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport const authOptions: NextAuthOptions = {\r\n  session: { strategy: \"jwt\" },\r\n  providers: [\r\n    CredentialsProvider({\r\n      name: \"Credentials\",\r\n      credentials: {\r\n        email: { label: \"E-posta\", type: \"email\" },\r\n        password: { label: \"Şifre\", type: \"password\" },\r\n      },\r\n      async authorize(credentials) {\r\n        try {\r\n          // Validate input with Zod\r\n          const { email, password } = await signInSchema.parseAsync(\r\n            credentials\r\n          );\r\n\r\n          // Find user by email\r\n          const user = await prisma.user.findUnique({\r\n            where: { email },\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              phone: true,\r\n              role: true,\r\n              password_hash: true,\r\n            },\r\n          });\r\n\r\n          if (!user) {\r\n            throw new Error(\"Geçersiz e-posta veya şifre\");\r\n          }\r\n\r\n          // Verify password\r\n          const isValid = await verifyPassword(password, user.password_hash);\r\n\r\n          if (!isValid) {\r\n            throw new Error(\"Geçersiz e-posta veya şifre\");\r\n          }\r\n\r\n          // Return user object without password_hash\r\n          return {\r\n            id: user.id,\r\n            name: user.name,\r\n            email: user.email,\r\n            phone: user.phone,\r\n            role: user.role,\r\n          };\r\n        } catch (error) {\r\n          if (error instanceof ZodError) {\r\n            // Invalid credentials format\r\n            return null;\r\n          }\r\n          // Re-throw other errors\r\n          throw error;\r\n        }\r\n      },\r\n    }),\r\n  ],\r\n  callbacks: {\r\n    async jwt({ token, user }) {\r\n      // On first sign-in, add user role to token\r\n      if (user) {\r\n        token.id = user.id;\r\n        token.role = user.role;\r\n        token.phone = user.phone;\r\n      }\r\n      return token;\r\n    },\r\n    async session({ session, token }) {\r\n      // Add user ID and role to session\r\n      if (token) {\r\n        session.user.id = token.id as string;\r\n        session.user.role = token.role as string;\r\n        session.user.phone = token.phone as string | null;\r\n      }\r\n      return session;\r\n    },\r\n  },\r\n};\r\n\r\nexport default NextAuth(authOptions);\r\n\r\n// Helper to get session in server components (Next.js App Router)\r\nexport { getServerSession } from \"next-auth/next\";\r\n\r\n// Extend NextAuth types for TypeScript\r\ndeclare module \"next-auth\" {\r\n  interface Session {\r\n    user: {\r\n      id: string;\r\n      name?: string | null;\r\n      email?: string | null;\r\n      image?: string | null;\r\n      phone?: string | null;\r\n      role: string;\r\n    };\r\n  }\r\n\r\n  interface User {\r\n    id: string;\r\n    role: string;\r\n    phone?: string | null;\r\n  }\r\n}\r\n\r\ndeclare module \"next-auth/jwt\" {\r\n  interface JWT {\r\n    id: string;\r\n    role: string;\r\n    phone?: string | null;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAuFA,kEAAkE;AAClE;;;;;;;AAtFA,MAAM,SAAS,IAAI,6IAAY;AAExB,MAAM,cAA+B;IAC1C,SAAS;QAAE,UAAU;IAAM;IAC3B,WAAW;QACT,IAAA,iRAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAW,MAAM;gBAAQ;gBACzC,UAAU;oBAAE,OAAO;oBAAS,MAAM;gBAAW;YAC/C;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI;oBACF,0BAA0B;oBAC1B,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,MAAM,2IAAY,CAAC,UAAU,CACvD;oBAGF,qBAAqB;oBACrB,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;wBACxC,OAAO;4BAAE;wBAAM;wBACf,QAAQ;4BACN,IAAI;4BACJ,MAAM;4BACN,OAAO;4BACP,OAAO;4BACP,MAAM;4BACN,eAAe;wBACjB;oBACF;oBAEA,IAAI,CAAC,MAAM;wBACT,MAAM,IAAI,MAAM;oBAClB;oBAEA,kBAAkB;oBAClB,MAAM,UAAU,MAAM,IAAA,4IAAc,EAAC,UAAU,KAAK,aAAa;oBAEjE,IAAI,CAAC,SAAS;wBACZ,MAAM,IAAI,MAAM;oBAClB;oBAEA,2CAA2C;oBAC3C,OAAO;wBACL,IAAI,KAAK,EAAE;wBACX,MAAM,KAAK,IAAI;wBACf,OAAO,KAAK,KAAK;wBACjB,OAAO,KAAK,KAAK;wBACjB,MAAM,KAAK,IAAI;oBACjB;gBACF,EAAE,OAAO,OAAO;oBACd,IAAI,iBAAiB,6MAAQ,EAAE;wBAC7B,6BAA6B;wBAC7B,OAAO;oBACT;oBACA,wBAAwB;oBACxB,MAAM;gBACR;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,2CAA2C;YAC3C,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,IAAI,GAAG,KAAK,IAAI;gBACtB,MAAM,KAAK,GAAG,KAAK,KAAK;YAC1B;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,kCAAkC;YAClC,IAAI,OAAO;gBACT,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;gBAC9B,QAAQ,IAAI,CAAC,KAAK,GAAG,MAAM,KAAK;YAClC;YACA,OAAO;QACT;IACF;AACF;uCAEe,IAAA,8PAAQ,EAAC","debugId":null}},
    {"offset": {"line": 322, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/lib/auth/abilities.ts"],"sourcesContent":["import { Role } from \"@prisma/client\";\r\n\r\n/**\r\n * Permission types for RBAC system.\r\n * Each permission represents a specific action in the system.\r\n */\r\nexport type Permission =\r\n  // Appointment permissions\r\n  | \"appointment:create\"\r\n  | \"appointment:read\"\r\n  | \"appointment:read:all\"\r\n  | \"appointment:update\"\r\n  | \"appointment:update:all\"\r\n  | \"appointment:approve\"\r\n  | \"appointment:cancel\"\r\n  | \"appointment:delete\"\r\n  // Service permissions\r\n  | \"service:create\"\r\n  | \"service:read\"\r\n  | \"service:update\"\r\n  | \"service:delete\"\r\n  // User permissions\r\n  | \"user:create\"\r\n  | \"user:read\"\r\n  | \"user:read:all\"\r\n  | \"user:update\"\r\n  | \"user:update:all\"\r\n  | \"user:delete\"\r\n  // Review permissions\r\n  | \"review:create\"\r\n  | \"review:read\"\r\n  | \"review:update:own\"\r\n  | \"review:update:all\"\r\n  | \"review:delete:own\"\r\n  | \"review:delete:all\"\r\n  // Gallery permissions\r\n  | \"gallery:create\"\r\n  | \"gallery:read\"\r\n  | \"gallery:update\"\r\n  | \"gallery:delete\"\r\n  // Payment permissions\r\n  | \"payment:create\"\r\n  | \"payment:read\"\r\n  | \"payment:read:all\"\r\n  | \"payment:update\"\r\n  | \"payment:delete\"\r\n  // Report permissions\r\n  | \"report:financial:read\"\r\n  | \"report:operational:read\"\r\n  | \"report:export\"\r\n  // Settings permissions\r\n  | \"settings:read\"\r\n  | \"settings:update\"\r\n  // Staff permissions\r\n  | \"staff:read\"\r\n  | \"staff:create\"\r\n  | \"staff:update\"\r\n  | \"staff:delete\"\r\n  | \"staff:invite\"\r\n  // Working hours permissions\r\n  | \"working-hours:read\"\r\n  | \"working-hours:update\"\r\n  // Notification permissions\r\n  | \"notification:read\"\r\n  | \"notification:send\"\r\n  | \"notification:send:all\";\r\n\r\n/**\r\n * Role-to-permissions mapping.\r\n * Defines which permissions each role has access to.\r\n *\r\n * ADMIN: Full access to all features\r\n * STAFF: Can manage appointments, payments, view reports, limited user management\r\n * CUSTOMER: Can create appointments, view own data, create reviews\r\n */\r\nexport const rolePermissions: Record<Role, Permission[]> = {\r\n  [Role.ADMIN]: [\r\n    // Appointments\r\n    \"appointment:create\",\r\n    \"appointment:read\",\r\n    \"appointment:read:all\",\r\n    \"appointment:update\",\r\n    \"appointment:update:all\",\r\n    \"appointment:approve\",\r\n    \"appointment:cancel\",\r\n    \"appointment:delete\",\r\n    // Services\r\n    \"service:create\",\r\n    \"service:read\",\r\n    \"service:update\",\r\n    \"service:delete\",\r\n    // Users\r\n    \"user:create\",\r\n    \"user:read\",\r\n    \"user:read:all\",\r\n    \"user:update\",\r\n    \"user:update:all\",\r\n    \"user:delete\",\r\n    // Reviews\r\n    \"review:create\",\r\n    \"review:read\",\r\n    \"review:update:own\",\r\n    \"review:update:all\",\r\n    \"review:delete:own\",\r\n    \"review:delete:all\",\r\n    // Gallery\r\n    \"gallery:create\",\r\n    \"gallery:read\",\r\n    \"gallery:update\",\r\n    \"gallery:delete\",\r\n    // Payments\r\n    \"payment:create\",\r\n    \"payment:read\",\r\n    \"payment:read:all\",\r\n    \"payment:update\",\r\n    \"payment:delete\",\r\n    // Reports\r\n    \"report:financial:read\",\r\n    \"report:operational:read\",\r\n    \"report:export\",\r\n    // Settings\r\n    \"settings:read\",\r\n    \"settings:update\",\r\n    // Staff\r\n    \"staff:read\",\r\n    \"staff:create\",\r\n    \"staff:update\",\r\n    \"staff:delete\",\r\n    \"staff:invite\",\r\n    // Working hours\r\n    \"working-hours:read\",\r\n    \"working-hours:update\",\r\n    // Notifications\r\n    \"notification:read\",\r\n    \"notification:send\",\r\n    \"notification:send:all\",\r\n  ],\r\n\r\n  [Role.STAFF]: [\r\n    // Appointments\r\n    \"appointment:create\",\r\n    \"appointment:read\",\r\n    \"appointment:read:all\",\r\n    \"appointment:update\",\r\n    \"appointment:update:all\",\r\n    \"appointment:approve\",\r\n    \"appointment:cancel\",\r\n    // Services\r\n    \"service:read\",\r\n    // Users\r\n    \"user:read\",\r\n    // Reviews\r\n    \"review:read\",\r\n    // Gallery\r\n    \"gallery:read\",\r\n    // Payments\r\n    \"payment:create\",\r\n    \"payment:read\",\r\n    \"payment:read:all\",\r\n    \"payment:update\",\r\n    // Reports\r\n    \"report:financial:read\",\r\n    \"report:operational:read\",\r\n    \"report:export\",\r\n    // Settings\r\n    \"settings:read\",\r\n    // Staff\r\n    \"staff:read\",\r\n    // Working hours\r\n    \"working-hours:read\",\r\n    // Notifications\r\n    \"notification:read\",\r\n    \"notification:send\",\r\n  ],\r\n\r\n  [Role.CUSTOMER]: [\r\n    // Appointments\r\n    \"appointment:create\",\r\n    \"appointment:read\", // Own appointments only\r\n    \"appointment:cancel\", // Own appointments only, within 12-hour window\r\n    // Services\r\n    \"service:read\",\r\n    // Users\r\n    \"user:read\", // Own profile only\r\n    \"user:update\", // Own profile only\r\n    // Reviews\r\n    \"review:create\",\r\n    \"review:read\",\r\n    \"review:update:own\",\r\n    \"review:delete:own\",\r\n    // Gallery\r\n    \"gallery:read\",\r\n    // Payments\r\n    \"payment:read\", // Own payments only\r\n    // Notifications\r\n    \"notification:read\", // Own notifications only\r\n  ],\r\n};\r\n\r\n/**\r\n * Check if a role has a specific permission.\r\n * @param role - User's role\r\n * @param permission - Permission to check\r\n * @returns True if role has permission, false otherwise\r\n */\r\nexport function hasPermission(role: Role, permission: Permission): boolean {\r\n  return rolePermissions[role]?.includes(permission) ?? false;\r\n}\r\n\r\n/**\r\n * Check if a user has multiple permissions (AND logic).\r\n * @param role - User's role\r\n * @param permissions - Array of permissions to check\r\n * @returns True if role has ALL permissions, false otherwise\r\n */\r\nexport function hasAllPermissions(\r\n  role: Role,\r\n  permissions: Permission[]\r\n): boolean {\r\n  return permissions.every((permission) => hasPermission(role, permission));\r\n}\r\n\r\n/**\r\n * Check if a user has at least one of the given permissions (OR logic).\r\n * @param role - User's role\r\n * @param permissions - Array of permissions to check\r\n * @returns True if role has AT LEAST ONE permission, false otherwise\r\n */\r\nexport function hasAnyPermission(\r\n  role: Role,\r\n  permissions: Permission[]\r\n): boolean {\r\n  return permissions.some((permission) => hasPermission(role, permission));\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AA2EO,MAAM,kBAA8C;IACzD,CAAC,qIAAI,CAAC,KAAK,CAAC,EAAE;QACZ,eAAe;QACf;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,WAAW;QACX;QACA;QACA;QACA;QACA,QAAQ;QACR;QACA;QACA;QACA;QACA;QACA;QACA,UAAU;QACV;QACA;QACA;QACA;QACA;QACA;QACA,UAAU;QACV;QACA;QACA;QACA;QACA,WAAW;QACX;QACA;QACA;QACA;QACA;QACA,UAAU;QACV;QACA;QACA;QACA,WAAW;QACX;QACA;QACA,QAAQ;QACR;QACA;QACA;QACA;QACA;QACA,gBAAgB;QAChB;QACA;QACA,gBAAgB;QAChB;QACA;QACA;KACD;IAED,CAAC,qIAAI,CAAC,KAAK,CAAC,EAAE;QACZ,eAAe;QACf;QACA;QACA;QACA;QACA;QACA;QACA;QACA,WAAW;QACX;QACA,QAAQ;QACR;QACA,UAAU;QACV;QACA,UAAU;QACV;QACA,WAAW;QACX;QACA;QACA;QACA;QACA,UAAU;QACV;QACA;QACA;QACA,WAAW;QACX;QACA,QAAQ;QACR;QACA,gBAAgB;QAChB;QACA,gBAAgB;QAChB;QACA;KACD;IAED,CAAC,qIAAI,CAAC,QAAQ,CAAC,EAAE;QACf,eAAe;QACf;QACA;QACA;QACA,WAAW;QACX;QACA,QAAQ;QACR;QACA;QACA,UAAU;QACV;QACA;QACA;QACA;QACA,UAAU;QACV;QACA,WAAW;QACX;QACA,gBAAgB;QAChB;KACD;AACH;AAQO,SAAS,cAAc,IAAU,EAAE,UAAsB;IAC9D,OAAO,eAAe,CAAC,KAAK,EAAE,SAAS,eAAe;AACxD;AAQO,SAAS,kBACd,IAAU,EACV,WAAyB;IAEzB,OAAO,YAAY,KAAK,CAAC,CAAC,aAAe,cAAc,MAAM;AAC/D;AAQO,SAAS,iBACd,IAAU,EACV,WAAyB;IAEzB,OAAO,YAAY,IAAI,CAAC,CAAC,aAAe,cAAc,MAAM;AAC9D","debugId":null}},
    {"offset": {"line": 468, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/lib/auth/guards.ts"],"sourcesContent":["import { Role } from \"@prisma/client\";\r\nimport { getServerSession } from \"next-auth/next\";\r\nimport { authOptions } from \"@/lib/auth\";\r\nimport {\r\n  hasPermission,\r\n  hasAllPermissions,\r\n  hasAnyPermission,\r\n  type Permission,\r\n} from \"./abilities\";\r\n\r\n/**\r\n * Error thrown when user lacks required permissions.\r\n */\r\nexport class UnauthorizedError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"UnauthorizedError\";\r\n  }\r\n}\r\n\r\n/**\r\n * Get the current session or throw if not authenticated.\r\n * @throws UnauthorizedError if no session exists\r\n */\r\nexport async function requireAuth() {\r\n  const session = await getServerSession(authOptions);\r\n\r\n  if (!session || !session.user) {\r\n    throw new UnauthorizedError(\"Bu işlem için giriş yapmalısınız\");\r\n  }\r\n\r\n  return session;\r\n}\r\n\r\n/**\r\n * Require user to have a specific role.\r\n * @param allowedRoles - Single role or array of roles\r\n * @throws UnauthorizedError if user role doesn't match\r\n */\r\nexport async function requireRole(allowedRoles: Role | Role[]) {\r\n  const session = await requireAuth();\r\n  const roles = Array.isArray(allowedRoles) ? allowedRoles : [allowedRoles];\r\n\r\n  if (!roles.includes(session.user.role as Role)) {\r\n    throw new UnauthorizedError(\r\n      \"Bu işlemi gerçekleştirmek için yetkiniz bulunmamaktadır\"\r\n    );\r\n  }\r\n\r\n  return session;\r\n}\r\n\r\n/**\r\n * Require user to have a specific permission.\r\n * @param permission - Permission to check\r\n * @throws UnauthorizedError if user lacks permission\r\n */\r\nexport async function requirePermission(permission: Permission) {\r\n  const session = await requireAuth();\r\n\r\n  if (!hasPermission(session.user.role as Role, permission)) {\r\n    throw new UnauthorizedError(\r\n      \"Bu işlemi gerçekleştirmek için yetkiniz bulunmamaktadır\"\r\n    );\r\n  }\r\n\r\n  return session;\r\n}\r\n\r\n/**\r\n * Require user to have ALL of the specified permissions.\r\n * @param permissions - Array of permissions to check (AND logic)\r\n * @throws UnauthorizedError if user lacks any permission\r\n */\r\nexport async function requireAllPermissions(permissions: Permission[]) {\r\n  const session = await requireAuth();\r\n\r\n  if (!hasAllPermissions(session.user.role as Role, permissions)) {\r\n    throw new UnauthorizedError(\r\n      \"Bu işlemi gerçekleştirmek için yetkiniz bulunmamaktadır\"\r\n    );\r\n  }\r\n\r\n  return session;\r\n}\r\n\r\n/**\r\n * Require user to have AT LEAST ONE of the specified permissions.\r\n * @param permissions - Array of permissions to check (OR logic)\r\n * @throws UnauthorizedError if user lacks all permissions\r\n */\r\nexport async function requireAnyPermission(permissions: Permission[]) {\r\n  const session = await requireAuth();\r\n\r\n  if (!hasAnyPermission(session.user.role as Role, permissions)) {\r\n    throw new UnauthorizedError(\r\n      \"Bu işlemi gerçekleştirmek için yetkiniz bulunmamaktadır\"\r\n    );\r\n  }\r\n\r\n  return session;\r\n}\r\n\r\n/**\r\n * Check if current user is ADMIN.\r\n * @throws UnauthorizedError if user is not admin\r\n */\r\nexport async function requireAdmin() {\r\n  return requireRole(Role.ADMIN);\r\n}\r\n\r\n/**\r\n * Check if current user is STAFF or ADMIN.\r\n * @throws UnauthorizedError if user is neither staff nor admin\r\n */\r\nexport async function requireStaffOrAdmin() {\r\n  return requireRole([Role.STAFF, Role.ADMIN]);\r\n}\r\n\r\n/**\r\n * Check if current user can access a specific user's data.\r\n * Admins can access any user, others can only access their own data.\r\n * @param userId - ID of the user whose data is being accessed\r\n * @throws UnauthorizedError if user cannot access the data\r\n */\r\nexport async function requireOwnershipOrAdmin(userId: string) {\r\n  const session = await requireAuth();\r\n\r\n  const isAdmin = session.user.role === Role.ADMIN;\r\n  const isOwner = session.user.id === userId;\r\n\r\n  if (!isAdmin && !isOwner) {\r\n    throw new UnauthorizedError(\"Bu bilgilere erişim yetkiniz bulunmamaktadır\");\r\n  }\r\n\r\n  return session;\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAUO,MAAM,0BAA0B;IACrC,YAAY,OAAe,CAAE;QAC3B,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAMO,eAAe;IACpB,MAAM,UAAU,MAAM,IAAA,+QAAgB,EAAC,4IAAW;IAElD,IAAI,CAAC,WAAW,CAAC,QAAQ,IAAI,EAAE;QAC7B,MAAM,IAAI,kBAAkB;IAC9B;IAEA,OAAO;AACT;AAOO,eAAe,YAAY,YAA2B;IAC3D,MAAM,UAAU,MAAM;IACtB,MAAM,QAAQ,MAAM,OAAO,CAAC,gBAAgB,eAAe;QAAC;KAAa;IAEzE,IAAI,CAAC,MAAM,QAAQ,CAAC,QAAQ,IAAI,CAAC,IAAI,GAAW;QAC9C,MAAM,IAAI,kBACR;IAEJ;IAEA,OAAO;AACT;AAOO,eAAe,kBAAkB,UAAsB;IAC5D,MAAM,UAAU,MAAM;IAEtB,IAAI,CAAC,IAAA,2IAAa,EAAC,QAAQ,IAAI,CAAC,IAAI,EAAU,aAAa;QACzD,MAAM,IAAI,kBACR;IAEJ;IAEA,OAAO;AACT;AAOO,eAAe,sBAAsB,WAAyB;IACnE,MAAM,UAAU,MAAM;IAEtB,IAAI,CAAC,IAAA,+IAAiB,EAAC,QAAQ,IAAI,CAAC,IAAI,EAAU,cAAc;QAC9D,MAAM,IAAI,kBACR;IAEJ;IAEA,OAAO;AACT;AAOO,eAAe,qBAAqB,WAAyB;IAClE,MAAM,UAAU,MAAM;IAEtB,IAAI,CAAC,IAAA,8IAAgB,EAAC,QAAQ,IAAI,CAAC,IAAI,EAAU,cAAc;QAC7D,MAAM,IAAI,kBACR;IAEJ;IAEA,OAAO;AACT;AAMO,eAAe;IACpB,OAAO,YAAY,qIAAI,CAAC,KAAK;AAC/B;AAMO,eAAe;IACpB,OAAO,YAAY;QAAC,qIAAI,CAAC,KAAK;QAAE,qIAAI,CAAC,KAAK;KAAC;AAC7C;AAQO,eAAe,wBAAwB,MAAc;IAC1D,MAAM,UAAU,MAAM;IAEtB,MAAM,UAAU,QAAQ,IAAI,CAAC,IAAI,KAAK,qIAAI,CAAC,KAAK;IAChD,MAAM,UAAU,QAAQ,IAAI,CAAC,EAAE,KAAK;IAEpC,IAAI,CAAC,WAAW,CAAC,SAAS;QACxB,MAAM,IAAI,kBAAkB;IAC9B;IAEA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 562, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/lib/validation/appointment.ts"],"sourcesContent":["import { z } from \"zod\";\r\n\r\n/**\r\n * Appointment request schema for both guest and registered users.\r\n * Registered users may have pre-filled name/email/phone from session.\r\n */\r\nexport const appointmentRequestSchema = z\r\n  .object({\r\n    // Customer info (required for guests, optional for registered users)\r\n    customer_name: z\r\n      .string()\r\n      .min(1, { message: \"Ad soyad gereklidir\" })\r\n      .min(2, { message: \"Ad soyad en az 2 karakter olmalıdır\" }),\r\n    customer_phone: z\r\n      .string()\r\n      .min(1, { message: \"Telefon numarası gereklidir\" })\r\n      .refine((val) => /^(\\+90|0)?5\\d{9}$/.test(val.replace(/\\s/g, \"\")), {\r\n        message: \"Geçerli bir telefon numarası giriniz (örn: 5551234567)\",\r\n      }),\r\n    customer_email: z\r\n      .string()\r\n      .email({ message: \"Geçerli bir e-posta adresi giriniz\" })\r\n      .optional()\r\n      .or(z.literal(\"\")),\r\n\r\n    // Appointment details\r\n    service_ids: z\r\n      .array(z.string())\r\n      .min(1, { message: \"En az bir hizmet seçmelisiniz\" }),\r\n    date: z\r\n      .string()\r\n      .min(1, { message: \"Randevu tarihi gereklidir\" })\r\n      .refine(\r\n        (val) => {\r\n          const selectedDate = new Date(val);\r\n          const today = new Date();\r\n          today.setHours(0, 0, 0, 0);\r\n          return selectedDate >= today;\r\n        },\r\n        { message: \"Geçmiş bir tarih seçemezsiniz\" }\r\n      ),\r\n    time: z\r\n      .string()\r\n      .min(1, { message: \"Randevu saati gereklidir\" })\r\n      .refine((val) => /^\\d{2}:\\d{2}$/.test(val), {\r\n        message: \"Geçerli bir saat giriniz (HH:mm)\",\r\n      }),\r\n    people_count: z\r\n      .number()\r\n      .int()\r\n      .min(1, { message: \"En az 1 kişi olmalıdır\" })\r\n      .max(10, { message: \"En fazla 10 kişi için randevu alabilirsiniz\" }),\r\n    notes: z\r\n      .string()\r\n      .max(500, { message: \"Not en fazla 500 karakter olabilir\" })\r\n      .optional()\r\n      .or(z.literal(\"\")),\r\n  })\r\n  .superRefine((data, ctx) => {\r\n    // Check if date + time is in the past\r\n    if (data.date && data.time) {\r\n      const [year, month, day] = data.date.split(\"-\").map(Number);\r\n      const [hours, minutes] = data.time.split(\":\").map(Number);\r\n      const appointmentDateTime = new Date(\r\n        year,\r\n        month - 1,\r\n        day,\r\n        hours,\r\n        minutes\r\n      );\r\n      const now = new Date();\r\n\r\n      if (appointmentDateTime <= now) {\r\n        ctx.addIssue({\r\n          code: z.ZodIssueCode.custom,\r\n          message: \"Geçmiş bir tarih ve saat seçemezsiniz\",\r\n          path: [\"time\"],\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\nexport type AppointmentRequestInput = z.infer<typeof appointmentRequestSchema>;\r\n\r\n/**\r\n * Appointment approval schema for admin/staff.\r\n * Used when approving or revising a PENDING appointment.\r\n */\r\nexport const appointmentApprovalSchema = z\r\n  .object({\r\n    appointment_id: z.string().min(1),\r\n    assigned_staff_id: z\r\n      .string()\r\n      .min(1, { message: \"Çalışan ataması gereklidir\" }),\r\n    date: z.string().min(1, { message: \"Tarih gereklidir\" }),\r\n    time: z.string().min(1, { message: \"Saat gereklidir\" }),\r\n    service_ids: z\r\n      .array(z.string())\r\n      .min(1, { message: \"En az bir hizmet gereklidir\" }),\r\n    people_count: z.number().int().min(1).max(10),\r\n    notes_internal: z\r\n      .string()\r\n      .max(1000, { message: \"İç not en fazla 1000 karakter olabilir\" })\r\n      .optional()\r\n      .or(z.literal(\"\")),\r\n  })\r\n  .superRefine((data, ctx) => {\r\n    // Check if date + time is in the past\r\n    if (data.date && data.time) {\r\n      const [year, month, day] = data.date.split(\"-\").map(Number);\r\n      const [hours, minutes] = data.time.split(\":\").map(Number);\r\n      const appointmentDateTime = new Date(\r\n        year,\r\n        month - 1,\r\n        day,\r\n        hours,\r\n        minutes\r\n      );\r\n      const now = new Date();\r\n\r\n      if (appointmentDateTime <= now) {\r\n        ctx.addIssue({\r\n          code: z.ZodIssueCode.custom,\r\n          message: \"Geçmiş bir tarih ve saat seçemezsiniz\",\r\n          path: [\"time\"],\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\nexport type AppointmentApprovalInput = z.infer<\r\n  typeof appointmentApprovalSchema\r\n>;\r\n\r\n/**\r\n * Appointment cancellation schema.\r\n * Includes reason for cancellation.\r\n */\r\nexport const appointmentCancellationSchema = z.object({\r\n  appointment_id: z.string().min(1),\r\n  reason: z\r\n    .string()\r\n    .min(1, { message: \"İptal nedeni gereklidir\" })\r\n    .max(500, { message: \"İptal nedeni en fazla 500 karakter olabilir\" }),\r\n});\r\n\r\nexport type AppointmentCancellationInput = z.infer<\r\n  typeof appointmentCancellationSchema\r\n>;\r\n\r\n/**\r\n * Follow-up code lookup schema.\r\n * Used to check appointment status by code.\r\n */\r\nexport const followUpCodeSchema = z.object({\r\n  code: z\r\n    .string()\r\n    .min(1, { message: \"Takip kodu gereklidir\" })\r\n    .regex(/^APT-\\d{4}-\\d{5}$/, {\r\n      message: \"Geçersiz takip kodu formatı (APT-YYYY-NNNNN)\",\r\n    }),\r\n});\r\n\r\nexport type FollowUpCodeInput = z.infer<typeof followUpCodeSchema>;\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 689, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/app/api/appointments/cancel/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { PrismaClient, AppointmentStatus } from \"@prisma/client\";\r\nimport { requireStaffOrAdmin } from \"@/lib/auth/guards\";\r\nimport { appointmentCancellationSchema } from \"@/lib/validation/appointment\";\r\nimport { z } from \"zod\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const session = await requireStaffOrAdmin();\r\n    const body = await request.json();\r\n\r\n    // Validate input\r\n    const validatedData = appointmentCancellationSchema.parse(body);\r\n\r\n    // Get existing appointment\r\n    const appointment = await prisma.appointment.findUnique({\r\n      where: { id: validatedData.appointment_id },\r\n    });\r\n\r\n    if (!appointment) {\r\n      return NextResponse.json(\r\n        { error: \"Randevu bulunamadı\" },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // Update appointment status to CANCELLED\r\n    const updatedAppointment = await prisma.appointment.update({\r\n      where: { id: validatedData.appointment_id },\r\n      data: {\r\n        status: AppointmentStatus.CANCELLED,\r\n        notes_internal: {\r\n          ...(appointment.notes_internal as any),\r\n          cancelled_by: session.user.id,\r\n          cancelled_at: new Date().toISOString(),\r\n          cancellation_reason: validatedData.reason,\r\n        },\r\n      },\r\n    });\r\n\r\n    // TODO: Send notification to customer (will be implemented in task 4.1-4.2)\r\n    // TODO: Log in AuditLog\r\n\r\n    return NextResponse.json({\r\n      message: \"Randevu başarıyla iptal edildi\",\r\n      appointment: updatedAppointment,\r\n    });\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      return NextResponse.json(\r\n        { error: error.issues[0].message },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    console.error(\"Appointment cancellation error:\", error);\r\n    return NextResponse.json(\r\n      { error: \"Randevu iptal edilirken bir hata oluştu\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA,MAAM,SAAS,IAAI,6IAAY;AAExB,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,UAAU,MAAM,IAAA,8IAAmB;QACzC,MAAM,OAAO,MAAM,QAAQ,IAAI;QAE/B,iBAAiB;QACjB,MAAM,gBAAgB,mKAA6B,CAAC,KAAK,CAAC;QAE1D,2BAA2B;QAC3B,MAAM,cAAc,MAAM,OAAO,WAAW,CAAC,UAAU,CAAC;YACtD,OAAO;gBAAE,IAAI,cAAc,cAAc;YAAC;QAC5C;QAEA,IAAI,CAAC,aAAa;YAChB,OAAO,+PAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAqB,GAC9B;gBAAE,QAAQ;YAAI;QAElB;QAEA,yCAAyC;QACzC,MAAM,qBAAqB,MAAM,OAAO,WAAW,CAAC,MAAM,CAAC;YACzD,OAAO;gBAAE,IAAI,cAAc,cAAc;YAAC;YAC1C,MAAM;gBACJ,QAAQ,kJAAiB,CAAC,SAAS;gBACnC,gBAAgB;oBACd,GAAI,YAAY,cAAc;oBAC9B,cAAc,QAAQ,IAAI,CAAC,EAAE;oBAC7B,cAAc,IAAI,OAAO,WAAW;oBACpC,qBAAqB,cAAc,MAAM;gBAC3C;YACF;QACF;QAEA,4EAA4E;QAC5E,wBAAwB;QAExB,OAAO,+PAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,aAAa;QACf;IACF,EAAE,OAAO,OAAO;QACd,IAAI,iBAAiB,qOAAC,CAAC,QAAQ,EAAE;YAC/B,OAAO,+PAAY,CAAC,IAAI,CACtB;gBAAE,OAAO,MAAM,MAAM,CAAC,EAAE,CAAC,OAAO;YAAC,GACjC;gBAAE,QAAQ;YAAI;QAElB;QAEA,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO,+PAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA0C,GACnD;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}
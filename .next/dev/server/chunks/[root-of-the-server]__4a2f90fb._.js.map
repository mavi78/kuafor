{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/lib/utils/appointment.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n/**\r\n * Generate a unique appointment follow-up code in format: APT-YYYY-NNNNN\r\n * where YYYY is the year and NNNNN is a sequential 5-digit number.\r\n *\r\n * @returns Promise<string> - Unique appointment code\r\n *\r\n * @example\r\n * const code = await generateAppointmentCode()\r\n * // Returns: \"APT-2025-00001\"\r\n */\r\nexport async function generateAppointmentCode(): Promise<string> {\r\n  const currentYear = new Date().getFullYear();\r\n  const yearPrefix = `APT-${currentYear}-`;\r\n\r\n  // Find the highest sequential number for this year\r\n  const lastAppointment = await prisma.appointment.findFirst({\r\n    where: {\r\n      code: {\r\n        startsWith: yearPrefix,\r\n      },\r\n    },\r\n    orderBy: {\r\n      code: \"desc\",\r\n    },\r\n    select: {\r\n      code: true,\r\n    },\r\n  });\r\n\r\n  let nextNumber = 1;\r\n\r\n  if (lastAppointment) {\r\n    // Extract the sequential number from the last code\r\n    const lastNumber = parseInt(lastAppointment.code.split(\"-\")[2], 10);\r\n    nextNumber = lastNumber + 1;\r\n  }\r\n\r\n  // Format with leading zeros (5 digits)\r\n  const sequentialNumber = nextNumber.toString().padStart(5, \"0\");\r\n\r\n  return `${yearPrefix}${sequentialNumber}`;\r\n}\r\n\r\n/**\r\n * Check if an appointment can be cancelled by the customer.\r\n * Customers can only cancel if there are more than 12 hours until the appointment.\r\n *\r\n * @param appointmentDate - Date of the appointment (YYYY-MM-DD)\r\n * @param appointmentTime - Time of the appointment (HH:mm)\r\n * @returns boolean - True if can be cancelled, false otherwise\r\n */\r\nexport function canCancelAppointment(\r\n  appointmentDate: string,\r\n  appointmentTime: string\r\n): boolean {\r\n  const now = new Date();\r\n  const [year, month, day] = appointmentDate.split(\"-\").map(Number);\r\n  const [hours, minutes] = appointmentTime.split(\":\").map(Number);\r\n\r\n  const appointmentDateTime = new Date(year, month - 1, day, hours, minutes);\r\n  const hoursUntilAppointment =\r\n    (appointmentDateTime.getTime() - now.getTime()) / (1000 * 60 * 60);\r\n\r\n  return hoursUntilAppointment > 12;\r\n}\r\n\r\n/**\r\n * Check if the selected time is within working hours.\r\n *\r\n * @param weekday - Day of week (0 = Sunday, 6 = Saturday)\r\n * @param time - Time in HH:mm format\r\n * @param workingHours - Array of working hours from database\r\n * @param specialWorkingDays - Array of special working days from database\r\n * @param selectedDate - Date in YYYY-MM-DD format\r\n * @returns object - { isWithinHours: boolean, message?: string }\r\n */\r\nexport function checkWorkingHours(\r\n  weekday: number,\r\n  time: string,\r\n  workingHours: Array<{\r\n    weekday: number;\r\n    open_time: string | null;\r\n    close_time: string | null;\r\n    is_open: boolean;\r\n  }>,\r\n  specialWorkingDays: Array<{\r\n    date: Date;\r\n    open_time: string | null;\r\n    close_time: string | null;\r\n    is_open: boolean;\r\n  }>,\r\n  selectedDate: string\r\n): { isWithinHours: boolean; message?: string } {\r\n  // Check if there's a special working day for this date\r\n  const selectedDateObj = new Date(selectedDate);\r\n  const specialDay = specialWorkingDays.find((sd) => {\r\n    const sdDate = new Date(sd.date);\r\n    return (\r\n      sdDate.getFullYear() === selectedDateObj.getFullYear() &&\r\n      sdDate.getMonth() === selectedDateObj.getMonth() &&\r\n      sdDate.getDate() === selectedDateObj.getDate()\r\n    );\r\n  });\r\n\r\n  if (specialDay) {\r\n    if (!specialDay.is_open) {\r\n      return {\r\n        isWithinHours: false,\r\n        message:\r\n          \"Seçtiğiniz tarihte salonumuz kapalıdır. Lütfen başka bir tarih seçin.\",\r\n      };\r\n    }\r\n\r\n    if (specialDay.open_time && specialDay.close_time) {\r\n      if (time < specialDay.open_time || time >= specialDay.close_time) {\r\n        return {\r\n          isWithinHours: false,\r\n          message: `Seçtiğiniz saat çalışma saatlerimiz dışındadır. Çalışma saatlerimiz: ${specialDay.open_time} - ${specialDay.close_time}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    return { isWithinHours: true };\r\n  }\r\n\r\n  // Check regular working hours\r\n  const workingDay = workingHours.find((wh) => wh.weekday === weekday);\r\n\r\n  if (!workingDay || !workingDay.is_open) {\r\n    return {\r\n      isWithinHours: false,\r\n      message:\r\n        \"Seçtiğiniz gün salonumuz kapalıdır. Lütfen başka bir gün seçin.\",\r\n    };\r\n  }\r\n\r\n  if (workingDay.open_time && workingDay.close_time) {\r\n    if (time < workingDay.open_time || time >= workingDay.close_time) {\r\n      return {\r\n        isWithinHours: false,\r\n        message: `Seçtiğiniz saat çalışma saatlerimiz dışındadır. Çalışma saatlerimiz: ${workingDay.open_time} - ${workingDay.close_time}`,\r\n      };\r\n    }\r\n  }\r\n\r\n  return { isWithinHours: true };\r\n}\r\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEA,MAAM,SAAS,IAAI,6IAAY;AAYxB,eAAe;IACpB,MAAM,cAAc,IAAI,OAAO,WAAW;IAC1C,MAAM,aAAa,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;IAExC,mDAAmD;IACnD,MAAM,kBAAkB,MAAM,OAAO,WAAW,CAAC,SAAS,CAAC;QACzD,OAAO;YACL,MAAM;gBACJ,YAAY;YACd;QACF;QACA,SAAS;YACP,MAAM;QACR;QACA,QAAQ;YACN,MAAM;QACR;IACF;IAEA,IAAI,aAAa;IAEjB,IAAI,iBAAiB;QACnB,mDAAmD;QACnD,MAAM,aAAa,SAAS,gBAAgB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE;QAChE,aAAa,aAAa;IAC5B;IAEA,uCAAuC;IACvC,MAAM,mBAAmB,WAAW,QAAQ,GAAG,QAAQ,CAAC,GAAG;IAE3D,OAAO,GAAG,aAAa,kBAAkB;AAC3C;AAUO,SAAS,qBACd,eAAuB,EACvB,eAAuB;IAEvB,MAAM,MAAM,IAAI;IAChB,MAAM,CAAC,MAAM,OAAO,IAAI,GAAG,gBAAgB,KAAK,CAAC,KAAK,GAAG,CAAC;IAC1D,MAAM,CAAC,OAAO,QAAQ,GAAG,gBAAgB,KAAK,CAAC,KAAK,GAAG,CAAC;IAExD,MAAM,sBAAsB,IAAI,KAAK,MAAM,QAAQ,GAAG,KAAK,OAAO;IAClE,MAAM,wBACJ,CAAC,oBAAoB,OAAO,KAAK,IAAI,OAAO,EAAE,IAAI,CAAC,OAAO,KAAK,EAAE;IAEnE,OAAO,wBAAwB;AACjC;AAYO,SAAS,kBACd,OAAe,EACf,IAAY,EACZ,YAKE,EACF,kBAKE,EACF,YAAoB;IAEpB,uDAAuD;IACvD,MAAM,kBAAkB,IAAI,KAAK;IACjC,MAAM,aAAa,mBAAmB,IAAI,CAAC,CAAC;QAC1C,MAAM,SAAS,IAAI,KAAK,GAAG,IAAI;QAC/B,OACE,OAAO,WAAW,OAAO,gBAAgB,WAAW,MACpD,OAAO,QAAQ,OAAO,gBAAgB,QAAQ,MAC9C,OAAO,OAAO,OAAO,gBAAgB,OAAO;IAEhD;IAEA,IAAI,YAAY;QACd,IAAI,CAAC,WAAW,OAAO,EAAE;YACvB,OAAO;gBACL,eAAe;gBACf,SACE;YACJ;QACF;QAEA,IAAI,WAAW,SAAS,IAAI,WAAW,UAAU,EAAE;YACjD,IAAI,OAAO,WAAW,SAAS,IAAI,QAAQ,WAAW,UAAU,EAAE;gBAChE,OAAO;oBACL,eAAe;oBACf,SAAS,CAAC,qEAAqE,EAAE,WAAW,SAAS,CAAC,GAAG,EAAE,WAAW,UAAU,EAAE;gBACpI;YACF;QACF;QAEA,OAAO;YAAE,eAAe;QAAK;IAC/B;IAEA,8BAA8B;IAC9B,MAAM,aAAa,aAAa,IAAI,CAAC,CAAC,KAAO,GAAG,OAAO,KAAK;IAE5D,IAAI,CAAC,cAAc,CAAC,WAAW,OAAO,EAAE;QACtC,OAAO;YACL,eAAe;YACf,SACE;QACJ;IACF;IAEA,IAAI,WAAW,SAAS,IAAI,WAAW,UAAU,EAAE;QACjD,IAAI,OAAO,WAAW,SAAS,IAAI,QAAQ,WAAW,UAAU,EAAE;YAChE,OAAO;gBACL,eAAe;gBACf,SAAS,CAAC,qEAAqE,EAAE,WAAW,SAAS,CAAC,GAAG,EAAE,WAAW,UAAU,EAAE;YACpI;QACF;IACF;IAEA,OAAO;QAAE,eAAe;IAAK;AAC/B","debugId":null}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/app/api/appointments/validate/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\nimport { checkWorkingHours } from \"@/lib/utils/appointment\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body = await request.json();\r\n    const { date, time, staff_id, service_ids, appointment_id } = body;\r\n\r\n    const warnings: any = {\r\n      workingHoursWarning: null,\r\n      staffLeaveWarning: null,\r\n      conflicts: [],\r\n    };\r\n\r\n    // Check working hours\r\n    const [workingHours, specialWorkingDays] = await Promise.all([\r\n      prisma.workingHours.findMany(),\r\n      prisma.specialWorkingDay.findMany({\r\n        where: {\r\n          date: {\r\n            gte: new Date(date),\r\n            lte: new Date(date),\r\n          },\r\n        },\r\n      }),\r\n    ]);\r\n\r\n    const selectedDate = new Date(date);\r\n    const weekday = selectedDate.getDay();\r\n    const hoursCheck = checkWorkingHours(\r\n      weekday,\r\n      time,\r\n      workingHours,\r\n      specialWorkingDays,\r\n      date\r\n    );\r\n\r\n    if (!hoursCheck.isWithinHours && hoursCheck.message) {\r\n      warnings.workingHoursWarning = hoursCheck.message;\r\n    }\r\n\r\n    // Check staff leaves\r\n    if (staff_id) {\r\n      const staffLeave = await prisma.staffLeave.findFirst({\r\n        where: {\r\n          staff_user_id: staff_id,\r\n          start_date: {\r\n            lte: new Date(date),\r\n          },\r\n          end_date: {\r\n            gte: new Date(date),\r\n          },\r\n        },\r\n      });\r\n\r\n      if (staffLeave) {\r\n        warnings.staffLeaveWarning = `Seçilen çalışan ${new Date(\r\n          staffLeave.start_date\r\n        ).toLocaleDateString(\"tr-TR\")} - ${new Date(\r\n          staffLeave.end_date\r\n        ).toLocaleDateString(\"tr-TR\")} tarihleri arasında izinlidir.`;\r\n      }\r\n    }\r\n\r\n    // Check conflicts\r\n    if (staff_id && service_ids && service_ids.length > 0) {\r\n      const services = await prisma.service.findMany({\r\n        where: {\r\n          id: { in: service_ids },\r\n        },\r\n      });\r\n\r\n      const totalDuration = services.reduce(\r\n        (sum, s) => sum + s.duration_min,\r\n        0\r\n      );\r\n\r\n      // Parse time (HH:mm)\r\n      const [hours, minutes] = time.split(\":\").map(Number);\r\n      const appointmentStart = new Date(date);\r\n      appointmentStart.setHours(hours, minutes, 0, 0);\r\n\r\n      const appointmentEnd = new Date(appointmentStart);\r\n      appointmentEnd.setMinutes(appointmentEnd.getMinutes() + totalDuration);\r\n\r\n      // Find overlapping appointments for the same staff\r\n      const overlappingAppointments = await prisma.appointment.findMany({\r\n        where: {\r\n          id: {\r\n            not: appointment_id, // Exclude current appointment\r\n          },\r\n          assigned_staff_id: staff_id,\r\n          date: new Date(date),\r\n          status: {\r\n            in: [\"PENDING\", \"APPROVED\"],\r\n          },\r\n        },\r\n        include: {\r\n          appointment_services: {\r\n            include: {\r\n              service: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      const conflicts = overlappingAppointments.filter((apt) => {\r\n        const [aptHours, aptMinutes] = apt.time.split(\":\").map(Number);\r\n        const aptStart = new Date(date);\r\n        aptStart.setHours(aptHours, aptMinutes, 0, 0);\r\n\r\n        const aptDuration = apt.appointment_services.reduce(\r\n          (sum, as) => sum + as.service.duration_min,\r\n          0\r\n        );\r\n\r\n        const aptEnd = new Date(aptStart);\r\n        aptEnd.setMinutes(aptEnd.getMinutes() + aptDuration);\r\n\r\n        // Check if times overlap\r\n        return (\r\n          (appointmentStart >= aptStart && appointmentStart < aptEnd) ||\r\n          (appointmentEnd > aptStart && appointmentEnd <= aptEnd) ||\r\n          (appointmentStart <= aptStart && appointmentEnd >= aptEnd)\r\n        );\r\n      });\r\n\r\n      warnings.conflicts = conflicts.map((apt) => ({\r\n        id: apt.id,\r\n        customer_name: apt.customer_name,\r\n        time: apt.time,\r\n        duration: apt.appointment_services.reduce(\r\n          (sum, as) => sum + as.service.duration_min,\r\n          0\r\n        ),\r\n        services: apt.appointment_services.map((as) => as.service.name),\r\n      }));\r\n    }\r\n\r\n    return NextResponse.json(warnings);\r\n  } catch (error) {\r\n    console.error(\"Validation error:\", error);\r\n    return NextResponse.json(\r\n      { error: \"Doğrulama sırasında bir hata oluştu\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}
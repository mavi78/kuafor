{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/lib/validation/auth.ts"],"sourcesContent":["import { z } from 'zod'\r\n\r\n/**\r\n * Sign-in schema with email and password validation.\r\n * Used for login forms.\r\n */\r\nexport const signInSchema = z.object({\r\n  email: z\r\n    .string()\r\n    .min(1, { message: 'E-posta adresi gereklidir' })\r\n    .email({ message: 'Geçerli bir e-posta adresi giriniz' }),\r\n  password: z\r\n    .string()\r\n    .min(1, { message: 'Şifre gereklidir' })\r\n    .min(6, { message: 'Şifre en az 6 karakter olmalıdır' }),\r\n})\r\n\r\nexport type SignInInput = z.infer<typeof signInSchema>\r\n\r\n/**\r\n * Sign-up schema with name, email, phone, and password validation.\r\n * Used for customer self-registration.\r\n */\r\nexport const signUpSchema = z.object({\r\n  name: z\r\n    .string()\r\n    .min(1, { message: 'Ad soyad gereklidir' })\r\n    .min(2, { message: 'Ad soyad en az 2 karakter olmalıdır' }),\r\n  email: z\r\n    .string()\r\n    .min(1, { message: 'E-posta adresi gereklidir' })\r\n    .email({ message: 'Geçerli bir e-posta adresi giriniz' }),\r\n  phone: z\r\n    .string()\r\n    .optional()\r\n    .refine(\r\n      (val) => !val || /^(\\+90|0)?5\\d{9}$/.test(val.replace(/\\s/g, '')),\r\n      { message: 'Geçerli bir telefon numarası giriniz (örn: 5551234567)' }\r\n    ),\r\n  password: z\r\n    .string()\r\n    .min(1, { message: 'Şifre gereklidir' })\r\n    .min(6, { message: 'Şifre en az 6 karakter olmalıdır' }),\r\n  confirmPassword: z.string().min(1, { message: 'Şifre tekrarı gereklidir' }),\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n  message: 'Şifreler eşleşmiyor',\r\n  path: ['confirmPassword'],\r\n})\r\n\r\nexport type SignUpInput = z.infer<typeof signUpSchema>\r\n\r\n/**\r\n * Password reset request schema.\r\n * Used for initiating password reset flow.\r\n */\r\nexport const passwordResetRequestSchema = z.object({\r\n  email: z\r\n    .string()\r\n    .min(1, { message: 'E-posta adresi gereklidir' })\r\n    .email({ message: 'Geçerli bir e-posta adresi giriniz' }),\r\n})\r\n\r\nexport type PasswordResetRequestInput = z.infer<typeof passwordResetRequestSchema>\r\n\r\n/**\r\n * Password reset confirmation schema.\r\n * Used for completing password reset with token.\r\n */\r\nexport const passwordResetConfirmSchema = z.object({\r\n  token: z.string().min(1, { message: 'Token gereklidir' }),\r\n  password: z\r\n    .string()\r\n    .min(1, { message: 'Şifre gereklidir' })\r\n    .min(6, { message: 'Şifre en az 6 karakter olmalıdır' }),\r\n  confirmPassword: z.string().min(1, { message: 'Şifre tekrarı gereklidir' }),\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n  message: 'Şifreler eşleşmiyor',\r\n  path: ['confirmPassword'],\r\n})\r\n\r\nexport type PasswordResetConfirmInput = z.infer<typeof passwordResetConfirmSchema>\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAMO,MAAM,eAAe,qOAAC,CAAC,MAAM,CAAC;IACnC,OAAO,qOAAC,CACL,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAA4B,GAC9C,KAAK,CAAC;QAAE,SAAS;IAAqC;IACzD,UAAU,qOAAC,CACR,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmB,GACrC,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmC;AAC1D;AAQO,MAAM,eAAe,qOAAC,CAAC,MAAM,CAAC;IACnC,MAAM,qOAAC,CACJ,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAAsB,GACxC,GAAG,CAAC,GAAG;QAAE,SAAS;IAAsC;IAC3D,OAAO,qOAAC,CACL,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAA4B,GAC9C,KAAK,CAAC;QAAE,SAAS;IAAqC;IACzD,OAAO,qOAAC,CACL,MAAM,GACN,QAAQ,GACR,MAAM,CACL,CAAC,MAAQ,CAAC,OAAO,oBAAoB,IAAI,CAAC,IAAI,OAAO,CAAC,OAAO,MAC7D;QAAE,SAAS;IAAyD;IAExE,UAAU,qOAAC,CACR,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmB,GACrC,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmC;IACxD,iBAAiB,qOAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAA2B;AAC3E,GAAG,MAAM,CAAC,CAAC,OAAS,KAAK,QAAQ,KAAK,KAAK,eAAe,EAAE;IAC1D,SAAS;IACT,MAAM;QAAC;KAAkB;AAC3B;AAQO,MAAM,6BAA6B,qOAAC,CAAC,MAAM,CAAC;IACjD,OAAO,qOAAC,CACL,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAA4B,GAC9C,KAAK,CAAC;QAAE,SAAS;IAAqC;AAC3D;AAQO,MAAM,6BAA6B,qOAAC,CAAC,MAAM,CAAC;IACjD,OAAO,qOAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmB;IACvD,UAAU,qOAAC,CACR,MAAM,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmB,GACrC,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmC;IACxD,iBAAiB,qOAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAA2B;AAC3E,GAAG,MAAM,CAAC,CAAC,OAAS,KAAK,QAAQ,KAAK,KAAK,eAAe,EAAE;IAC1D,SAAS;IACT,MAAM;QAAC;KAAkB;AAC3B","debugId":null}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/lib/utils/password.ts"],"sourcesContent":["import { hash, compare } from \"bcryptjs\";\r\n\r\nconst SALT_ROUNDS = 10;\r\n\r\n/**\r\n * Hash a plain-text password using bcryptjs.\r\n * @param password - Plain-text password\r\n * @returns Hashed password string\r\n */\r\nexport async function hashPassword(password: string): Promise<string> {\r\n  return hash(password, SALT_ROUNDS);\r\n}\r\n\r\n/**\r\n * Verify a plain-text password against a hashed password.\r\n * @param password - Plain-text password\r\n * @param hashedPassword - Hashed password from database\r\n * @returns True if passwords match, false otherwise\r\n */\r\nexport async function verifyPassword(\r\n  password: string,\r\n  hashedPassword: string\r\n): Promise<boolean> {\r\n  return compare(password, hashedPassword);\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,MAAM,cAAc;AAOb,eAAe,aAAa,QAAgB;IACjD,OAAO,IAAA,gMAAI,EAAC,UAAU;AACxB;AAQO,eAAe,eACpB,QAAgB,EAChB,cAAsB;IAEtB,OAAO,IAAA,mMAAO,EAAC,UAAU;AAC3B","debugId":null}},
    {"offset": {"line": 212, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/lib/auth.ts"],"sourcesContent":["import NextAuth, { NextAuthOptions } from \"next-auth\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\nimport CredentialsProvider from \"next-auth/providers/credentials\";\r\nimport { signInSchema } from \"@/lib/validation/auth\";\r\nimport { verifyPassword } from \"@/lib/utils/password\";\r\nimport { ZodError } from \"zod\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport const authOptions: NextAuthOptions = {\r\n  session: { strategy: \"jwt\" },\r\n  providers: [\r\n    CredentialsProvider({\r\n      name: \"Credentials\",\r\n      credentials: {\r\n        email: { label: \"E-posta\", type: \"email\" },\r\n        password: { label: \"Şifre\", type: \"password\" },\r\n      },\r\n      async authorize(credentials) {\r\n        try {\r\n          // Validate input with Zod\r\n          const { email, password } = await signInSchema.parseAsync(\r\n            credentials\r\n          );\r\n\r\n          // Find user by email\r\n          const user = await prisma.user.findUnique({\r\n            where: { email },\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              phone: true,\r\n              role: true,\r\n              password_hash: true,\r\n            },\r\n          });\r\n\r\n          if (!user) {\r\n            throw new Error(\"Geçersiz e-posta veya şifre\");\r\n          }\r\n\r\n          // Verify password\r\n          const isValid = await verifyPassword(password, user.password_hash);\r\n\r\n          if (!isValid) {\r\n            throw new Error(\"Geçersiz e-posta veya şifre\");\r\n          }\r\n\r\n          // Return user object without password_hash\r\n          return {\r\n            id: user.id,\r\n            name: user.name,\r\n            email: user.email,\r\n            phone: user.phone,\r\n            role: user.role,\r\n          };\r\n        } catch (error) {\r\n          if (error instanceof ZodError) {\r\n            // Invalid credentials format\r\n            return null;\r\n          }\r\n          // Re-throw other errors\r\n          throw error;\r\n        }\r\n      },\r\n    }),\r\n  ],\r\n  callbacks: {\r\n    async jwt({ token, user }) {\r\n      // On first sign-in, add user role to token\r\n      if (user) {\r\n        token.id = user.id;\r\n        token.role = user.role;\r\n        token.phone = user.phone;\r\n      }\r\n      return token;\r\n    },\r\n    async session({ session, token }) {\r\n      // Add user ID and role to session\r\n      if (token) {\r\n        session.user.id = token.id as string;\r\n        session.user.role = token.role as string;\r\n        session.user.phone = token.phone as string | null;\r\n      }\r\n      return session;\r\n    },\r\n  },\r\n};\r\n\r\nexport default NextAuth(authOptions);\r\n\r\n// Helper to get session in server components (Next.js App Router)\r\nexport { getServerSession } from \"next-auth/next\";\r\n\r\n// Extend NextAuth types for TypeScript\r\ndeclare module \"next-auth\" {\r\n  interface Session {\r\n    user: {\r\n      id: string;\r\n      name?: string | null;\r\n      email?: string | null;\r\n      image?: string | null;\r\n      phone?: string | null;\r\n      role: string;\r\n    };\r\n  }\r\n\r\n  interface User {\r\n    id: string;\r\n    role: string;\r\n    phone?: string | null;\r\n  }\r\n}\r\n\r\ndeclare module \"next-auth/jwt\" {\r\n  interface JWT {\r\n    id: string;\r\n    role: string;\r\n    phone?: string | null;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAuFA,kEAAkE;AAClE;;;;;;;AAtFA,MAAM,SAAS,IAAI,6IAAY;AAExB,MAAM,cAA+B;IAC1C,SAAS;QAAE,UAAU;IAAM;IAC3B,WAAW;QACT,IAAA,iRAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAW,MAAM;gBAAQ;gBACzC,UAAU;oBAAE,OAAO;oBAAS,MAAM;gBAAW;YAC/C;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI;oBACF,0BAA0B;oBAC1B,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,MAAM,2IAAY,CAAC,UAAU,CACvD;oBAGF,qBAAqB;oBACrB,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;wBACxC,OAAO;4BAAE;wBAAM;wBACf,QAAQ;4BACN,IAAI;4BACJ,MAAM;4BACN,OAAO;4BACP,OAAO;4BACP,MAAM;4BACN,eAAe;wBACjB;oBACF;oBAEA,IAAI,CAAC,MAAM;wBACT,MAAM,IAAI,MAAM;oBAClB;oBAEA,kBAAkB;oBAClB,MAAM,UAAU,MAAM,IAAA,4IAAc,EAAC,UAAU,KAAK,aAAa;oBAEjE,IAAI,CAAC,SAAS;wBACZ,MAAM,IAAI,MAAM;oBAClB;oBAEA,2CAA2C;oBAC3C,OAAO;wBACL,IAAI,KAAK,EAAE;wBACX,MAAM,KAAK,IAAI;wBACf,OAAO,KAAK,KAAK;wBACjB,OAAO,KAAK,KAAK;wBACjB,MAAM,KAAK,IAAI;oBACjB;gBACF,EAAE,OAAO,OAAO;oBACd,IAAI,iBAAiB,6MAAQ,EAAE;wBAC7B,6BAA6B;wBAC7B,OAAO;oBACT;oBACA,wBAAwB;oBACxB,MAAM;gBACR;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,2CAA2C;YAC3C,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,IAAI,GAAG,KAAK,IAAI;gBACtB,MAAM,KAAK,GAAG,KAAK,KAAK;YAC1B;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,kCAAkC;YAClC,IAAI,OAAO;gBACT,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;gBAC9B,QAAQ,IAAI,CAAC,KAAK,GAAG,MAAM,KAAK;YAClC;YACA,OAAO;QACT;IACF;AACF;uCAEe,IAAA,8PAAQ,EAAC","debugId":null}},
    {"offset": {"line": 322, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/lib/validation/appointment.ts"],"sourcesContent":["import { z } from \"zod\";\r\n\r\n/**\r\n * Appointment request schema for both guest and registered users.\r\n * Registered users may have pre-filled name/email/phone from session.\r\n */\r\nexport const appointmentRequestSchema = z\r\n  .object({\r\n    // Customer info (required for guests, optional for registered users)\r\n    customer_name: z\r\n      .string()\r\n      .min(1, { message: \"Ad soyad gereklidir\" })\r\n      .min(2, { message: \"Ad soyad en az 2 karakter olmalıdır\" }),\r\n    customer_phone: z\r\n      .string()\r\n      .min(1, { message: \"Telefon numarası gereklidir\" })\r\n      .refine((val) => /^(\\+90|0)?5\\d{9}$/.test(val.replace(/\\s/g, \"\")), {\r\n        message: \"Geçerli bir telefon numarası giriniz (örn: 5551234567)\",\r\n      }),\r\n    customer_email: z\r\n      .string()\r\n      .email({ message: \"Geçerli bir e-posta adresi giriniz\" })\r\n      .optional()\r\n      .or(z.literal(\"\")),\r\n\r\n    // Appointment details\r\n    service_ids: z\r\n      .array(z.string())\r\n      .min(1, { message: \"En az bir hizmet seçmelisiniz\" }),\r\n    date: z\r\n      .string()\r\n      .min(1, { message: \"Randevu tarihi gereklidir\" })\r\n      .refine(\r\n        (val) => {\r\n          const selectedDate = new Date(val);\r\n          const today = new Date();\r\n          today.setHours(0, 0, 0, 0);\r\n          return selectedDate >= today;\r\n        },\r\n        { message: \"Geçmiş bir tarih seçemezsiniz\" }\r\n      ),\r\n    time: z\r\n      .string()\r\n      .min(1, { message: \"Randevu saati gereklidir\" })\r\n      .refine((val) => /^\\d{2}:\\d{2}$/.test(val), {\r\n        message: \"Geçerli bir saat giriniz (HH:mm)\",\r\n      }),\r\n    people_count: z\r\n      .number()\r\n      .int()\r\n      .min(1, { message: \"En az 1 kişi olmalıdır\" })\r\n      .max(10, { message: \"En fazla 10 kişi için randevu alabilirsiniz\" }),\r\n    notes: z\r\n      .string()\r\n      .max(500, { message: \"Not en fazla 500 karakter olabilir\" })\r\n      .optional()\r\n      .or(z.literal(\"\")),\r\n  })\r\n  .superRefine((data, ctx) => {\r\n    // Check if date + time is in the past\r\n    if (data.date && data.time) {\r\n      const [year, month, day] = data.date.split(\"-\").map(Number);\r\n      const [hours, minutes] = data.time.split(\":\").map(Number);\r\n      const appointmentDateTime = new Date(\r\n        year,\r\n        month - 1,\r\n        day,\r\n        hours,\r\n        minutes\r\n      );\r\n      const now = new Date();\r\n\r\n      if (appointmentDateTime <= now) {\r\n        ctx.addIssue({\r\n          code: z.ZodIssueCode.custom,\r\n          message: \"Geçmiş bir tarih ve saat seçemezsiniz\",\r\n          path: [\"time\"],\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\nexport type AppointmentRequestInput = z.infer<typeof appointmentRequestSchema>;\r\n\r\n/**\r\n * Appointment approval schema for admin/staff.\r\n * Used when approving or revising a PENDING appointment.\r\n */\r\nexport const appointmentApprovalSchema = z\r\n  .object({\r\n    appointment_id: z.string().min(1),\r\n    assigned_staff_id: z\r\n      .string()\r\n      .min(1, { message: \"Çalışan ataması gereklidir\" }),\r\n    date: z.string().min(1, { message: \"Tarih gereklidir\" }),\r\n    time: z.string().min(1, { message: \"Saat gereklidir\" }),\r\n    service_ids: z\r\n      .array(z.string())\r\n      .min(1, { message: \"En az bir hizmet gereklidir\" }),\r\n    people_count: z.number().int().min(1).max(10),\r\n    notes_internal: z\r\n      .string()\r\n      .max(1000, { message: \"İç not en fazla 1000 karakter olabilir\" })\r\n      .optional()\r\n      .or(z.literal(\"\")),\r\n  })\r\n  .superRefine((data, ctx) => {\r\n    // Check if date + time is in the past\r\n    if (data.date && data.time) {\r\n      const [year, month, day] = data.date.split(\"-\").map(Number);\r\n      const [hours, minutes] = data.time.split(\":\").map(Number);\r\n      const appointmentDateTime = new Date(\r\n        year,\r\n        month - 1,\r\n        day,\r\n        hours,\r\n        minutes\r\n      );\r\n      const now = new Date();\r\n\r\n      if (appointmentDateTime <= now) {\r\n        ctx.addIssue({\r\n          code: z.ZodIssueCode.custom,\r\n          message: \"Geçmiş bir tarih ve saat seçemezsiniz\",\r\n          path: [\"time\"],\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\nexport type AppointmentApprovalInput = z.infer<\r\n  typeof appointmentApprovalSchema\r\n>;\r\n\r\n/**\r\n * Appointment cancellation schema.\r\n * Includes reason for cancellation.\r\n */\r\nexport const appointmentCancellationSchema = z.object({\r\n  appointment_id: z.string().min(1),\r\n  reason: z\r\n    .string()\r\n    .min(1, { message: \"İptal nedeni gereklidir\" })\r\n    .max(500, { message: \"İptal nedeni en fazla 500 karakter olabilir\" }),\r\n});\r\n\r\nexport type AppointmentCancellationInput = z.infer<\r\n  typeof appointmentCancellationSchema\r\n>;\r\n\r\n/**\r\n * Follow-up code lookup schema.\r\n * Used to check appointment status by code.\r\n */\r\nexport const followUpCodeSchema = z.object({\r\n  code: z\r\n    .string()\r\n    .min(1, { message: \"Takip kodu gereklidir\" })\r\n    .regex(/^APT-\\d{4}-\\d{5}$/, {\r\n      message: \"Geçersiz takip kodu formatı (APT-YYYY-NNNNN)\",\r\n    }),\r\n});\r\n\r\nexport type FollowUpCodeInput = z.infer<typeof followUpCodeSchema>;\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 449, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/lib/utils/appointment.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n/**\r\n * Generate a unique appointment follow-up code in format: APT-YYYY-NNNNN\r\n * where YYYY is the year and NNNNN is a sequential 5-digit number.\r\n *\r\n * @returns Promise<string> - Unique appointment code\r\n *\r\n * @example\r\n * const code = await generateAppointmentCode()\r\n * // Returns: \"APT-2025-00001\"\r\n */\r\nexport async function generateAppointmentCode(): Promise<string> {\r\n  const currentYear = new Date().getFullYear();\r\n  const yearPrefix = `APT-${currentYear}-`;\r\n\r\n  // Find the highest sequential number for this year\r\n  const lastAppointment = await prisma.appointment.findFirst({\r\n    where: {\r\n      code: {\r\n        startsWith: yearPrefix,\r\n      },\r\n    },\r\n    orderBy: {\r\n      code: \"desc\",\r\n    },\r\n    select: {\r\n      code: true,\r\n    },\r\n  });\r\n\r\n  let nextNumber = 1;\r\n\r\n  if (lastAppointment) {\r\n    // Extract the sequential number from the last code\r\n    const lastNumber = parseInt(lastAppointment.code.split(\"-\")[2], 10);\r\n    nextNumber = lastNumber + 1;\r\n  }\r\n\r\n  // Format with leading zeros (5 digits)\r\n  const sequentialNumber = nextNumber.toString().padStart(5, \"0\");\r\n\r\n  return `${yearPrefix}${sequentialNumber}`;\r\n}\r\n\r\n/**\r\n * Check if an appointment can be cancelled by the customer.\r\n * Customers can only cancel if there are more than 12 hours until the appointment.\r\n *\r\n * @param appointmentDate - Date of the appointment (YYYY-MM-DD)\r\n * @param appointmentTime - Time of the appointment (HH:mm)\r\n * @returns boolean - True if can be cancelled, false otherwise\r\n */\r\nexport function canCancelAppointment(\r\n  appointmentDate: string,\r\n  appointmentTime: string\r\n): boolean {\r\n  const now = new Date();\r\n  const [year, month, day] = appointmentDate.split(\"-\").map(Number);\r\n  const [hours, minutes] = appointmentTime.split(\":\").map(Number);\r\n\r\n  const appointmentDateTime = new Date(year, month - 1, day, hours, minutes);\r\n  const hoursUntilAppointment =\r\n    (appointmentDateTime.getTime() - now.getTime()) / (1000 * 60 * 60);\r\n\r\n  return hoursUntilAppointment > 12;\r\n}\r\n\r\n/**\r\n * Check if the selected time is within working hours.\r\n *\r\n * @param weekday - Day of week (0 = Sunday, 6 = Saturday)\r\n * @param time - Time in HH:mm format\r\n * @param workingHours - Array of working hours from database\r\n * @param specialWorkingDays - Array of special working days from database\r\n * @param selectedDate - Date in YYYY-MM-DD format\r\n * @returns object - { isWithinHours: boolean, message?: string }\r\n */\r\nexport function checkWorkingHours(\r\n  weekday: number,\r\n  time: string,\r\n  workingHours: Array<{\r\n    weekday: number;\r\n    open_time: string | null;\r\n    close_time: string | null;\r\n    is_open: boolean;\r\n  }>,\r\n  specialWorkingDays: Array<{\r\n    date: Date;\r\n    open_time: string | null;\r\n    close_time: string | null;\r\n    is_open: boolean;\r\n  }>,\r\n  selectedDate: string\r\n): { isWithinHours: boolean; message?: string } {\r\n  // Check if there's a special working day for this date\r\n  const selectedDateObj = new Date(selectedDate);\r\n  const specialDay = specialWorkingDays.find((sd) => {\r\n    const sdDate = new Date(sd.date);\r\n    return (\r\n      sdDate.getFullYear() === selectedDateObj.getFullYear() &&\r\n      sdDate.getMonth() === selectedDateObj.getMonth() &&\r\n      sdDate.getDate() === selectedDateObj.getDate()\r\n    );\r\n  });\r\n\r\n  if (specialDay) {\r\n    if (!specialDay.is_open) {\r\n      return {\r\n        isWithinHours: false,\r\n        message:\r\n          \"Seçtiğiniz tarihte salonumuz kapalıdır. Lütfen başka bir tarih seçin.\",\r\n      };\r\n    }\r\n\r\n    if (specialDay.open_time && specialDay.close_time) {\r\n      if (time < specialDay.open_time || time >= specialDay.close_time) {\r\n        return {\r\n          isWithinHours: false,\r\n          message: `Seçtiğiniz saat çalışma saatlerimiz dışındadır. Çalışma saatlerimiz: ${specialDay.open_time} - ${specialDay.close_time}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    return { isWithinHours: true };\r\n  }\r\n\r\n  // Check regular working hours\r\n  const workingDay = workingHours.find((wh) => wh.weekday === weekday);\r\n\r\n  if (!workingDay || !workingDay.is_open) {\r\n    return {\r\n      isWithinHours: false,\r\n      message:\r\n        \"Seçtiğiniz gün salonumuz kapalıdır. Lütfen başka bir gün seçin.\",\r\n    };\r\n  }\r\n\r\n  if (workingDay.open_time && workingDay.close_time) {\r\n    if (time < workingDay.open_time || time >= workingDay.close_time) {\r\n      return {\r\n        isWithinHours: false,\r\n        message: `Seçtiğiniz saat çalışma saatlerimiz dışındadır. Çalışma saatlerimiz: ${workingDay.open_time} - ${workingDay.close_time}`,\r\n      };\r\n    }\r\n  }\r\n\r\n  return { isWithinHours: true };\r\n}\r\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEA,MAAM,SAAS,IAAI,6IAAY;AAYxB,eAAe;IACpB,MAAM,cAAc,IAAI,OAAO,WAAW;IAC1C,MAAM,aAAa,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;IAExC,mDAAmD;IACnD,MAAM,kBAAkB,MAAM,OAAO,WAAW,CAAC,SAAS,CAAC;QACzD,OAAO;YACL,MAAM;gBACJ,YAAY;YACd;QACF;QACA,SAAS;YACP,MAAM;QACR;QACA,QAAQ;YACN,MAAM;QACR;IACF;IAEA,IAAI,aAAa;IAEjB,IAAI,iBAAiB;QACnB,mDAAmD;QACnD,MAAM,aAAa,SAAS,gBAAgB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE;QAChE,aAAa,aAAa;IAC5B;IAEA,uCAAuC;IACvC,MAAM,mBAAmB,WAAW,QAAQ,GAAG,QAAQ,CAAC,GAAG;IAE3D,OAAO,GAAG,aAAa,kBAAkB;AAC3C;AAUO,SAAS,qBACd,eAAuB,EACvB,eAAuB;IAEvB,MAAM,MAAM,IAAI;IAChB,MAAM,CAAC,MAAM,OAAO,IAAI,GAAG,gBAAgB,KAAK,CAAC,KAAK,GAAG,CAAC;IAC1D,MAAM,CAAC,OAAO,QAAQ,GAAG,gBAAgB,KAAK,CAAC,KAAK,GAAG,CAAC;IAExD,MAAM,sBAAsB,IAAI,KAAK,MAAM,QAAQ,GAAG,KAAK,OAAO;IAClE,MAAM,wBACJ,CAAC,oBAAoB,OAAO,KAAK,IAAI,OAAO,EAAE,IAAI,CAAC,OAAO,KAAK,EAAE;IAEnE,OAAO,wBAAwB;AACjC;AAYO,SAAS,kBACd,OAAe,EACf,IAAY,EACZ,YAKE,EACF,kBAKE,EACF,YAAoB;IAEpB,uDAAuD;IACvD,MAAM,kBAAkB,IAAI,KAAK;IACjC,MAAM,aAAa,mBAAmB,IAAI,CAAC,CAAC;QAC1C,MAAM,SAAS,IAAI,KAAK,GAAG,IAAI;QAC/B,OACE,OAAO,WAAW,OAAO,gBAAgB,WAAW,MACpD,OAAO,QAAQ,OAAO,gBAAgB,QAAQ,MAC9C,OAAO,OAAO,OAAO,gBAAgB,OAAO;IAEhD;IAEA,IAAI,YAAY;QACd,IAAI,CAAC,WAAW,OAAO,EAAE;YACvB,OAAO;gBACL,eAAe;gBACf,SACE;YACJ;QACF;QAEA,IAAI,WAAW,SAAS,IAAI,WAAW,UAAU,EAAE;YACjD,IAAI,OAAO,WAAW,SAAS,IAAI,QAAQ,WAAW,UAAU,EAAE;gBAChE,OAAO;oBACL,eAAe;oBACf,SAAS,CAAC,qEAAqE,EAAE,WAAW,SAAS,CAAC,GAAG,EAAE,WAAW,UAAU,EAAE;gBACpI;YACF;QACF;QAEA,OAAO;YAAE,eAAe;QAAK;IAC/B;IAEA,8BAA8B;IAC9B,MAAM,aAAa,aAAa,IAAI,CAAC,CAAC,KAAO,GAAG,OAAO,KAAK;IAE5D,IAAI,CAAC,cAAc,CAAC,WAAW,OAAO,EAAE;QACtC,OAAO;YACL,eAAe;YACf,SACE;QACJ;IACF;IAEA,IAAI,WAAW,SAAS,IAAI,WAAW,UAAU,EAAE;QACjD,IAAI,OAAO,WAAW,SAAS,IAAI,QAAQ,WAAW,UAAU,EAAE;YAChE,OAAO;gBACL,eAAe;gBACf,SAAS,CAAC,qEAAqE,EAAE,WAAW,SAAS,CAAC,GAAG,EAAE,WAAW,UAAU,EAAE;YACpI;QACF;IACF;IAEA,OAAO;QAAE,eAAe;IAAK;AAC/B","debugId":null}},
    {"offset": {"line": 545, "column": 0}, "map": {"version":3,"sources":["file:///E:/kuafor/app/api/appointments/create/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { PrismaClient, AppointmentStatus } from \"@prisma/client\";\r\nimport { getServerSession } from \"next-auth/next\";\r\nimport { authOptions } from \"@/lib/auth\";\r\nimport { appointmentRequestSchema } from \"@/lib/validation/appointment\";\r\nimport {\r\n  generateAppointmentCode,\r\n  checkWorkingHours,\r\n} from \"@/lib/utils/appointment\";\r\nimport { z } from \"zod\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const session = await getServerSession(authOptions);\r\n    const body = await request.json();\r\n\r\n    // Validate input\r\n    const validatedData = appointmentRequestSchema.parse(body);\r\n\r\n    // Get working hours and special working days\r\n    const workingHours = await prisma.workingHours.findMany();\r\n    const specialWorkingDays = await prisma.specialWorkingDay.findMany({\r\n      where: {\r\n        date: {\r\n          gte: new Date(validatedData.date),\r\n          lte: new Date(validatedData.date),\r\n        },\r\n      },\r\n    });\r\n\r\n    // Check if selected time is within working hours\r\n    const selectedDate = new Date(validatedData.date);\r\n    const weekday = selectedDate.getDay();\r\n    const hoursCheck = checkWorkingHours(\r\n      weekday,\r\n      validatedData.time,\r\n      workingHours,\r\n      specialWorkingDays,\r\n      validatedData.date\r\n    );\r\n\r\n    // If outside working hours, return warning (but still allow booking)\r\n    const warnings: string[] = [];\r\n    if (!hoursCheck.isWithinHours && hoursCheck.message) {\r\n      warnings.push(hoursCheck.message);\r\n    }\r\n\r\n    // Generate unique appointment code\r\n    const code = await generateAppointmentCode();\r\n\r\n    // Get service prices for booking record\r\n    const services = await prisma.service.findMany({\r\n      where: {\r\n        id: {\r\n          in: validatedData.service_ids,\r\n        },\r\n        is_active: true,\r\n      },\r\n    });\r\n\r\n    if (services.length !== validatedData.service_ids.length) {\r\n      return NextResponse.json(\r\n        { error: \"Seçilen hizmetlerden bazıları bulunamadı veya aktif değil\" },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Create appointment with PENDING status\r\n    const appointment = await prisma.appointment.create({\r\n      data: {\r\n        code,\r\n        customer_name: validatedData.customer_name,\r\n        customer_phone: validatedData.customer_phone,\r\n        customer_user_id: session?.user?.id || null,\r\n        people_count: validatedData.people_count,\r\n        date: new Date(validatedData.date),\r\n        time: validatedData.time,\r\n        status: AppointmentStatus.PENDING,\r\n        notes_internal: validatedData.notes\r\n          ? { customer_notes: validatedData.notes }\r\n          : undefined,\r\n        appointment_services: {\r\n          create: services.map((service) => ({\r\n            service_id: service.id,\r\n            price_try_at_booking: service.price_try,\r\n          })),\r\n        },\r\n      },\r\n      include: {\r\n        appointment_services: {\r\n          include: {\r\n            service: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    // TODO: Trigger notifications to admin/staff (will be implemented in task 4.1-4.2)\r\n    // await sendNotification({\r\n    //   channel: 'EMAIL',\r\n    //   to: 'admin@yildizkuaforu.com',\r\n    //   template: 'appointment_pending',\r\n    //   payload: { appointment, code },\r\n    // })\r\n\r\n    return NextResponse.json(\r\n      {\r\n        message: \"Randevu talebiniz başarıyla oluşturuldu\",\r\n        appointment: {\r\n          id: appointment.id,\r\n          code: appointment.code,\r\n          date: appointment.date,\r\n          time: appointment.time,\r\n          status: appointment.status,\r\n          services: appointment.appointment_services.map((as) => ({\r\n            name: as.service.name,\r\n            price: as.price_try_at_booking,\r\n          })),\r\n        },\r\n        warnings,\r\n      },\r\n      { status: 201 }\r\n    );\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      return NextResponse.json(\r\n        { error: error.issues[0].message },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    console.error(\"Appointment creation error:\", error);\r\n    return NextResponse.json(\r\n      { error: \"Randevu oluşturulurken bir hata oluştu\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}